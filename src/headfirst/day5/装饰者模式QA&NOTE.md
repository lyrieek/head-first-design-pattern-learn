## 继承的理解
> 继承尽管威力巨大，但是它并不能保持最有弹性和最好维护的设计

## 不通过继承如何达到复用呢？
> 利用组合和委托可以在运行时具有继承行为的效果:
> + 利用继承设计子类的行为，是在编译时静态决定的，所有子类都会继承到相同的行为。这显然不是我们希望的结果
> + 利用组合的做法扩展对象的行为，可以让我们能在运行时为对象动态扩展。
> + 利用组合可以把多个新的职责，甚至是设计超类时还没有想到的职责加在对象上，还不需要修改原来的代码
> + 通过动态的组合对象可以在不修改现有代码的前提下添加新的功能，这样产生额外bug和意外的可能性就大大的降低
> + 设计原则符合开闭原则:**对于扩展是开放的，对于修改是关闭的**

## 装饰者模式:
> + 装饰者和被装饰者具有相同的超类型
> + 你可以用一个或多个装饰者包装对象
> + 装饰者可以在委托被装饰者的行为之前/之后加上自己的行为，以达到目的
> + 对象可以在任何时候被装饰，所以可以在运行时，动态的，不限量的装饰对象
> + 所以装饰者模式会动态的将责任附加到对象上，比如java.io下的类，PushbackInputStream,BufferedInputStream,DataInputStream,LineNumberInputStream都继承自FilterInputStream这个装饰者父类，而FilterInputStream继承InputStream超类

# 本章要点:
1. 继承属于扩展形式的一种，但不见得是达到弹性设计的最佳方式
2. 在我们的设计中，应该允许行为在不修改当前代码的同时被扩展
3. 组合和委托可用于动态加上新行为
4. 除了继承，装饰者模式也可以让我们拓展行为(更有弹性)
5. 装饰者模式以为着一群装饰者的类，这些类用于包装各个组件
6. 装饰者类反映出被装饰者的组件类型(被装饰者和装饰者的父类都继承自一个接口或抽象类)
7. 你可以使用无数装饰者包装一个组件
8. 装饰者一般对组件的客户是透明的，除非客户组件依赖于装饰者的具体类型
9. 装饰者会导致设计中出现很多小对象，过度使用会导致程序过于复杂
